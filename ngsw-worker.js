!function(){"use strict";function __awaiter(t,e,i,s){return new(i||(i=Promise))((function(a,r){function fulfilled(t){try{step(s.next(t))}catch(t){r(t)}}function rejected(t){try{step(s.throw(t))}catch(t){r(t)}}function step(t){var e;t.done?a(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(fulfilled,rejected)}step((s=s.apply(t,e||[])).next())}))}class NamedCacheStorage{constructor(t,e){this.original=t,this.cacheNamePrefix=e}delete(t){return this.original.delete(`${this.cacheNamePrefix}:${t}`)}has(t){return this.original.has(`${this.cacheNamePrefix}:${t}`)}keys(){return __awaiter(this,void 0,void 0,(function*(){const t=`${this.cacheNamePrefix}:`;return(yield this.original.keys()).filter((e=>e.startsWith(t))).map((e=>e.slice(t.length)))}))}match(t,e){return this.original.match(t,e)}open(t){return __awaiter(this,void 0,void 0,(function*(){const e=yield this.original.open(`${this.cacheNamePrefix}:${t}`);return Object.assign(e,{name:t})}))}}class NotFound{constructor(t,e){this.table=t,this.key=e}}class CacheTable{constructor(t,e,i,s){this.name=t,this.cache=e,this.adapter=i,this.cacheQueryOptions=s,this.cacheName=this.cache.name}request(t){return this.adapter.newRequest("/"+t)}delete(t){return this.cache.delete(this.request(t),this.cacheQueryOptions)}keys(){return this.cache.keys().then((t=>t.map((t=>t.url.substr(1)))))}read(t){return this.cache.match(this.request(t),this.cacheQueryOptions).then((e=>void 0===e?Promise.reject(new NotFound(this.name,t)):e.json()))}write(t,e){return this.cache.put(this.request(t),this.adapter.newResponse(JSON.stringify(e)))}}var t=function(t){return t[t.NOT_CACHED=0]="NOT_CACHED",t[t.CACHED_BUT_UNUSED=1]="CACHED_BUT_UNUSED",t[t.CACHED=2]="CACHED",t}({});class SwCriticalError extends Error{constructor(){super(...arguments),this.isCritical=!0}}function errorToString(t){return t instanceof Error?`${t.message}\n${t.stack}`:`${t}`}class SwUnrecoverableStateError extends SwCriticalError{constructor(){super(...arguments),this.isUnrecoverableState=!0}}function sha1(t){const i=t;return _sha1(stringToWords32(i,e.Big),8*i.length)}function sha1Binary(t){return _sha1(arrayBufferToWords32(t,e.Big),8*t.byteLength)}function _sha1(t,e){const i=[];let[s,a,r,n,o]=[1732584193,4023233417,2562383102,271733878,3285377520];t[e>>5]|=128<<24-e%32,t[15+(e+64>>9<<4)]=e;for(let e=0;e<t.length;e+=16){const[h,l,c,u,d]=[s,a,r,n,o];for(let h=0;h<80;h++){i[h]=h<16?t[e+h]:rol32(i[h-3]^i[h-8]^i[h-14]^i[h-16],1);const[l,c]=fk(h,a,r,n),u=[rol32(s,5),l,o,c,i[h]].reduce(add32);[o,n,r,a,s]=[n,r,rol32(a,30),s,u]}[s,a,r,n,o]=[add32(s,h),add32(a,l),add32(r,c),add32(n,u),add32(o,d)]}return byteStringToHexString(words32ToByteString([s,a,r,n,o]))}function add32(t,e){return add32to64(t,e)[1]}function add32to64(t,e){const i=(65535&t)+(65535&e),s=(t>>>16)+(e>>>16)+(i>>>16);return[s>>>16,s<<16|65535&i]}function rol32(t,e){return t<<e|t>>>32-e}var e=function(t){return t[t.Little=0]="Little",t[t.Big=1]="Big",t}({});function fk(t,e,i,s){return t<20?[e&i|~e&s,1518500249]:t<40?[e^i^s,1859775393]:t<60?[e&i|e&s|i&s,2400959708]:[e^i^s,3395469782]}function stringToWords32(t,e){const i=t.length+3>>>2,s=[];for(let a=0;a<i;a++)s[a]=wordAt(t,4*a,e);return s}function arrayBufferToWords32(t,e){const i=t.byteLength+3>>>2,s=[],a=new Uint8Array(t);for(let t=0;t<i;t++)s[t]=wordAt(a,4*t,e);return s}function byteAt(t,e){return"string"==typeof t?e>=t.length?0:255&t.charCodeAt(e):e>=t.byteLength?0:255&t[e]}function wordAt(t,i,s){let a=0;if(s===e.Big)for(let e=0;e<4;e++)a+=byteAt(t,i+e)<<24-8*e;else for(let e=0;e<4;e++)a+=byteAt(t,i+e)<<8*e;return a}function words32ToByteString(t){return t.reduce(((t,e)=>t+word32ToByteString(e)),"")}function word32ToByteString(t){let e="";for(let i=0;i<4;i++)e+=String.fromCharCode(t>>>8*(3-i)&255);return e}function byteStringToHexString(t){let e="";for(let i=0;i<t.length;i++){const s=byteAt(t,i);e+=(s>>>4).toString(16)+(15&s).toString(16)}return e.toLowerCase()}class AssetGroup{constructor(t,e,i,s,a,r,n){this.scope=t,this.adapter=e,this.idle=i,this.config=s,this.hashes=a,this.db=r,this.inFlightRequests=new Map,this.urls=[],this.patterns=[],this.name=s.name,this.urls=s.urls.map((t=>e.normalizeUrl(t))),this.patterns=s.patterns.map((t=>new RegExp(t))),this.cache=e.caches.open(`${n}:${s.name}:cache`),this.metadata=this.db.open(`${n}:${s.name}:meta`,s.cacheQueryOptions)}cacheStatus(e){return __awaiter(this,void 0,void 0,(function*(){const i=yield this.cache,s=yield this.metadata,a=this.adapter.newRequest(e);if(void 0===(yield i.match(a,this.config.cacheQueryOptions)))return t.NOT_CACHED;try{if(!(yield s.read(a.url)).used)return t.CACHED_BUT_UNUSED}catch(t){}return t.CACHED}))}getCacheNames(){return __awaiter(this,void 0,void 0,(function*(){const[t,e]=yield Promise.all([this.cache,this.metadata]);return[t.name,e.cacheName]}))}handleFetch(t,e){return __awaiter(this,void 0,void 0,(function*(){const e=this.adapter.normalizeUrl(t.url);if(-1!==this.urls.indexOf(e)||this.patterns.some((t=>t.test(e)))){const i=yield this.cache,s=yield i.match(t,this.config.cacheQueryOptions);if(void 0!==s)return this.hashes.has(e)||(yield this.needToRevalidate(t,s))&&this.idle.schedule(`revalidate(${i.name}): ${t.url}`,(()=>__awaiter(this,void 0,void 0,(function*(){yield this.fetchAndCacheOnce(t)})))),s;return(yield this.fetchAndCacheOnce(this.adapter.newRequest(t.url))).clone()}return null}))}needToRevalidate(t,e){return __awaiter(this,void 0,void 0,(function*(){if(e.headers.has("Cache-Control")){const i=e.headers.get("Cache-Control").split(",").map((t=>t.trim())).map((t=>t.split("=")));i.forEach((t=>t[0]=t[0].toLowerCase()));const s=i.find((t=>"max-age"===t[0])),a=s?s[1]:void 0;if(!a)return!0;try{const i=1e3*parseInt(a);let s;try{const e=yield this.metadata;s=(yield e.read(t.url)).ts}catch(t){const i=e.headers.get("Date");if(null===i)return!0;s=Date.parse(i)}const r=this.adapter.time-s;return r<0||r>i}catch(t){return!0}}else{if(!e.headers.has("Expires"))return!0;{const t=e.headers.get("Expires");try{return this.adapter.time>Date.parse(t)}catch(t){return!0}}}}))}fetchFromCacheOnly(t){return __awaiter(this,void 0,void 0,(function*(){const e=yield this.cache,i=yield this.metadata,s=this.adapter.newRequest(t),a=yield e.match(s,this.config.cacheQueryOptions);if(void 0===a)return null;let r;try{r=yield i.read(s.url)}catch(t){}return{response:a,metadata:r}}))}unhashedResources(){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.cache;return(yield t.keys()).map((t=>this.adapter.normalizeUrl(t.url))).filter((t=>!this.hashes.has(t)))}))}fetchAndCacheOnce(t,e=!0){return __awaiter(this,void 0,void 0,(function*(){if(this.inFlightRequests.has(t.url))return this.inFlightRequests.get(t.url);const i=this.fetchFromNetwork(t);this.inFlightRequests.set(t.url,i);try{const s=yield i;if(!s.ok)throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${t.url} returned response ${s.status} ${s.statusText}`);try{const i=yield this.cache;if(yield i.put(t,s.clone()),!this.hashes.has(this.adapter.normalizeUrl(t.url))){const i={ts:this.adapter.time,used:e},s=yield this.metadata;yield s.write(t.url,i)}return s}catch(e){throw new SwCriticalError(`Failed to update the caches for request to '${t.url}' (fetchAndCacheOnce): ${errorToString(e)}`)}}finally{this.inFlightRequests.delete(t.url)}}))}fetchFromNetwork(t,e=3){return __awaiter(this,void 0,void 0,(function*(){const i=yield this.cacheBustedFetchFromNetwork(t);if(i.redirected&&i.url){if(0===e)throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${i.url}`);return this.fetchFromNetwork(this.adapter.newRequest(i.url),e-1)}return i}))}cacheBustedFetchFromNetwork(t){return __awaiter(this,void 0,void 0,(function*(){const e=this.adapter.normalizeUrl(t.url);if(this.hashes.has(e)){const i=this.hashes.get(e);let s=yield this.safeFetch(t),a=s.ok;if(a){a=sha1Binary(yield s.clone().arrayBuffer())!==i}if(a){const e=this.adapter.newRequest(this.cacheBust(t.url));if(s=yield this.safeFetch(e),s.ok){const e=sha1Binary(yield s.clone().arrayBuffer());if(i!==e)throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${t.url}: expected ${i}, got ${e} (after cache busting)`)}}if(!s.ok&&404===s.status)throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${e})`);return s}return this.safeFetch(t)}))}maybeUpdate(t,e,i){return __awaiter(this,void 0,void 0,(function*(){const s=this.adapter.normalizeUrl(e.url);if(this.hashes.has(s)){const a=this.hashes.get(s),r=yield t.lookupResourceWithHash(s,a);if(null!==r)return yield i.put(e,r),!0}return!1}))}cacheBust(t){return t+(-1===t.indexOf("?")?"?":"&")+"ngsw-cache-bust="+Math.random()}safeFetch(t){return __awaiter(this,void 0,void 0,(function*(){try{return yield this.scope.fetch(t)}catch(t){return this.adapter.newResponse("",{status:504,statusText:"Gateway Timeout"})}}))}}class PrefetchAssetGroup extends AssetGroup{initializeFully(t){return __awaiter(this,void 0,void 0,(function*(){const e=yield this.cache;if(yield this.urls.reduce(((i,s)=>__awaiter(this,void 0,void 0,(function*(){yield i;const a=this.adapter.newRequest(s);void 0!==(yield e.match(a,this.config.cacheQueryOptions))||void 0!==t&&(yield this.maybeUpdate(t,a,e))||(yield this.fetchAndCacheOnce(a,!1))}))),Promise.resolve()),void 0!==t){const i=yield this.metadata;yield(yield t.previouslyCachedResources()).filter((t=>-1!==this.urls.indexOf(t)||this.patterns.some((e=>e.test(t))))).reduce(((s,a)=>__awaiter(this,void 0,void 0,(function*(){yield s;const r=this.adapter.newRequest(a);if(void 0!==(yield e.match(r,this.config.cacheQueryOptions)))return;const n=yield t.lookupResourceWithoutHash(a);null!==n&&void 0!==n.metadata&&(yield e.put(r,n.response),yield i.write(r.url,Object.assign(Object.assign({},n.metadata),{used:!1})))}))),Promise.resolve())}}))}}class LazyAssetGroup extends AssetGroup{initializeFully(e){return __awaiter(this,void 0,void 0,(function*(){if(void 0===e)return;const i=yield this.cache;yield this.urls.reduce(((s,a)=>__awaiter(this,void 0,void 0,(function*(){yield s;const r=this.adapter.newRequest(a);if(void 0!==(yield i.match(r,this.config.cacheQueryOptions)))return;const n=yield this.maybeUpdate(e,r,i);if("prefetch"===this.config.updateMode&&!n){if((yield e.recentCacheStatus(a))!==t.CACHED)return;yield this.fetchAndCacheOnce(r,!1)}}))),Promise.resolve())}))}}class LruList{constructor(t){void 0===t&&(t={head:null,tail:null,map:{},count:0}),this.state=t}get size(){return this.state.count}pop(){if(null===this.state.tail)return null;const t=this.state.tail;return this.remove(t),t}remove(t){const e=this.state.map[t];if(void 0===e)return!1;if(this.state.head===t){if(null===e.next)return this.state.head=null,this.state.tail=null,this.state.map={},this.state.count=0,!0;const i=this.state.map[e.next];return i.previous=null,this.state.head=i.url,e.next=null,delete this.state.map[t],this.state.count--,!0}return this.state.map[e.previous].next=e.next,null!==e.next?this.state.map[e.next].previous=e.previous:this.state.tail=e.previous,e.next=null,e.previous=null,delete this.state.map[t],this.state.count--,!0}accessed(t){if(this.state.head===t)return;const e=this.state.map[t]||{url:t,next:null,previous:null};void 0!==this.state.map[t]&&this.remove(t),null!==this.state.head&&(this.state.map[this.state.head].previous=t),e.next=this.state.head,this.state.head=t,null===this.state.tail&&(this.state.tail=t),this.state.map[t]=e,this.state.count++}}class DataGroup{constructor(t,e,i,s,a,r){this.scope=t,this.adapter=e,this.config=i,this.db=s,this.debugHandler=a,this._lru=null,this.patterns=i.patterns.map((t=>new RegExp(t))),this.cache=e.caches.open(`${r}:${i.name}:cache`),this.lruTable=this.db.open(`${r}:${i.name}:lru`,i.cacheQueryOptions),this.ageTable=this.db.open(`${r}:${i.name}:age`,i.cacheQueryOptions)}lru(){return __awaiter(this,void 0,void 0,(function*(){if(null===this._lru){const t=yield this.lruTable;try{this._lru=new LruList(yield t.read("lru"))}catch(t){this._lru=new LruList}}return this._lru}))}syncLru(){return __awaiter(this,void 0,void 0,(function*(){if(null===this._lru)return;const t=yield this.lruTable;try{return t.write("lru",this._lru.state)}catch(t){this.debugHandler.log(t,`DataGroup(${this.config.name}@${this.config.version}).syncLru()`)}}))}handleFetch(t,e){return __awaiter(this,void 0,void 0,(function*(){if(!this.patterns.some((e=>e.test(t.url))))return null;const i=yield this.lru();switch(t.method){case"OPTIONS":return null;case"GET":case"HEAD":switch(this.config.strategy){case"freshness":return this.handleFetchWithFreshness(t,e,i);case"performance":return this.handleFetchWithPerformance(t,e,i);default:throw new Error(`Unknown strategy: ${this.config.strategy}`)}default:return i.remove(t.url)&&(yield this.clearCacheForUrl(t.url)),yield this.syncLru(),this.safeFetch(t)}}))}handleFetchWithPerformance(t,e,i){return __awaiter(this,void 0,void 0,(function*(){let s=null;const a=yield this.loadFromCache(t,i);if(null!==a&&(s=a.res,void 0!==this.config.refreshAheadMs&&a.age>=this.config.refreshAheadMs&&e.waitUntil(this.safeCacheResponse(t,this.safeFetch(t),i))),null!==s)return s;const[r,n]=this.networkFetchWithTimeout(t);return s=yield r,void 0===s?(s=this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"}),e.waitUntil(this.safeCacheResponse(t,n,i))):yield this.safeCacheResponse(t,s,i),s}))}handleFetchWithFreshness(t,e,i){return __awaiter(this,void 0,void 0,(function*(){const[s,a]=this.networkFetchWithTimeout(t);let r;try{r=yield s}catch(t){r=void 0}if(void 0===r){e.waitUntil(this.safeCacheResponse(t,a,i,!0));const s=yield this.loadFromCache(t,i);r=null!==s?s.res:null}else yield this.safeCacheResponse(t,r,i,!0);return null!==r?r:a}))}networkFetchWithTimeout(t){if(void 0!==this.config.timeoutMs){const e=this.scope.fetch(t),i=(()=>__awaiter(this,void 0,void 0,(function*(){try{return yield e}catch(t){return this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}})))(),s=(()=>__awaiter(this,void 0,void 0,(function*(){try{return yield e}catch(t){return}})))(),a=this.adapter.timeout(this.config.timeoutMs);return[Promise.race([s,a]),i]}{const e=this.safeFetch(t);return[e,e]}}safeCacheResponse(t,e,i,s){return __awaiter(this,void 0,void 0,(function*(){try{const a=yield e;try{yield this.cacheResponse(t,a,i,s)}catch(e){this.debugHandler.log(e,`DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${t.url}, status: ${a.status})`)}}catch(t){}}))}loadFromCache(t,e){return __awaiter(this,void 0,void 0,(function*(){const i=yield this.cache;let s=yield i.match(t,this.config.cacheQueryOptions);if(void 0!==s){try{const i=yield this.ageTable,a=this.adapter.time-(yield i.read(t.url)).age;if(a<=this.config.maxAge)return e.accessed(t.url),{res:s,age:a}}catch(t){}e.remove(t.url),yield this.clearCacheForUrl(t.url),yield this.syncLru()}return null}))}cacheResponse(t,e,i,s=!1){return __awaiter(this,void 0,void 0,(function*(){if(!(e.ok||s&&"opaque"===e.type))return;if(i.size>=this.config.maxSize){const t=i.pop();null!==t&&(yield this.clearCacheForUrl(t))}i.accessed(t.url),yield(yield this.cache).put(t,e.clone());const a=yield this.ageTable;yield a.write(t.url,{age:this.adapter.time}),yield this.syncLru()}))}cleanup(){return __awaiter(this,void 0,void 0,(function*(){yield Promise.all([this.cache.then((t=>this.adapter.caches.delete(t.name))),this.ageTable.then((t=>this.db.delete(t.name))),this.lruTable.then((t=>this.db.delete(t.name)))])}))}getCacheNames(){return __awaiter(this,void 0,void 0,(function*(){const[t,e,i]=yield Promise.all([this.cache,this.ageTable,this.lruTable]);return[t.name,e.cacheName,i.cacheName]}))}clearCacheForUrl(t){return __awaiter(this,void 0,void 0,(function*(){const[e,i]=yield Promise.all([this.cache,this.ageTable]);yield Promise.all([e.delete(this.adapter.newRequest(t,{method:"GET"}),this.config.cacheQueryOptions),e.delete(this.adapter.newRequest(t,{method:"HEAD"}),this.config.cacheQueryOptions),i.delete(t)])}))}safeFetch(t){return __awaiter(this,void 0,void 0,(function*(){try{return this.scope.fetch(t)}catch(t){return this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}}))}}const i=[{positive:!0,regex:"^/.*$"},{positive:!1,regex:"^/.*\\.[^/]*$"},{positive:!1,regex:"^/.*__"}];class AppVersion{constructor(t,e,s,a,r,n,o){this.scope=t,this.adapter=e,this.database=s,this.debugHandler=r,this.manifest=n,this.manifestHash=o,this.hashTable=new Map,this.indexUrl=this.adapter.normalizeUrl(this.manifest.index),this._okay=!0,Object.keys(n.hashTable).forEach((t=>{this.hashTable.set(e.normalizeUrl(t),n.hashTable[t])}));const h=`${o}:assets`;this.assetGroups=(n.assetGroups||[]).map((i=>{switch(i.installMode){case"prefetch":return new PrefetchAssetGroup(t,e,a,i,this.hashTable,s,h);case"lazy":return new LazyAssetGroup(t,e,a,i,this.hashTable,s,h)}})),this.dataGroups=(n.dataGroups||[]).map((i=>new DataGroup(t,e,i,s,r,`${i.version}:data`))),n.navigationUrls=n.navigationUrls||i;const l=n.navigationUrls.filter((t=>t.positive)),c=n.navigationUrls.filter((t=>!t.positive));this.navigationUrls={include:l.map((t=>new RegExp(t.regex))),exclude:c.map((t=>new RegExp(t.regex)))}}get okay(){return this._okay}initializeFully(t){return __awaiter(this,void 0,void 0,(function*(){try{yield this.assetGroups.reduce(((e,i)=>__awaiter(this,void 0,void 0,(function*(){return yield e,i.initializeFully(t)}))),Promise.resolve())}catch(t){throw this._okay=!1,t}}))}handleFetch(t,e){return __awaiter(this,void 0,void 0,(function*(){const i=yield this.assetGroups.reduce(((i,s)=>__awaiter(this,void 0,void 0,(function*(){const a=yield i;return null!==a?a:s.handleFetch(t,e)}))),Promise.resolve(null));if(null!==i)return i;const s=yield this.dataGroups.reduce(((i,s)=>__awaiter(this,void 0,void 0,(function*(){const a=yield i;return null!==a?a:s.handleFetch(t,e)}))),Promise.resolve(null));if(null!==s)return s;if(this.adapter.normalizeUrl(t.url)!==this.indexUrl&&this.isNavigationRequest(t)){if("freshness"===this.manifest.navigationRequestStrategy)try{return yield this.scope.fetch(t)}catch(t){}return this.handleFetch(this.adapter.newRequest(this.indexUrl),e)}return null}))}isNavigationRequest(t){if("navigate"!==t.mode)return!1;if(!this.acceptsTextHtml(t))return!1;const e=this.scope.registration.scope.replace(/\/$/,""),i=(t.url.startsWith(e)?t.url.substr(e.length):t.url).replace(/[?#].*$/,"");return this.navigationUrls.include.some((t=>t.test(i)))&&!this.navigationUrls.exclude.some((t=>t.test(i)))}lookupResourceWithHash(t,e){return __awaiter(this,void 0,void 0,(function*(){if(!this.hashTable.has(t))return null;if(this.hashTable.get(t)!==e)return null;const i=yield this.lookupResourceWithoutHash(t);return i&&i.response}))}lookupResourceWithoutHash(t){return this.assetGroups.reduce(((e,i)=>__awaiter(this,void 0,void 0,(function*(){const s=yield e;return null!==s?s:i.fetchFromCacheOnly(t)}))),Promise.resolve(null))}previouslyCachedResources(){return this.assetGroups.reduce(((t,e)=>__awaiter(this,void 0,void 0,(function*(){return(yield t).concat(yield e.unhashedResources())}))),Promise.resolve([]))}recentCacheStatus(e){return __awaiter(this,void 0,void 0,(function*(){return this.assetGroups.reduce(((i,s)=>__awaiter(this,void 0,void 0,(function*(){const a=yield i;if(a===t.CACHED)return a;const r=yield s.cacheStatus(e);return r===t.NOT_CACHED?a:r}))),Promise.resolve(t.NOT_CACHED))}))}getCacheNames(){return __awaiter(this,void 0,void 0,(function*(){const t=yield Promise.all([...this.assetGroups.map((t=>t.getCacheNames())),...this.dataGroups.map((t=>t.getCacheNames()))]);return[].concat(...t)}))}get appData(){return this.manifest.appData||null}acceptsTextHtml(t){const e=t.headers.get("Accept");if(null===e)return!1;return e.split(",").some((t=>"text/html"===t.trim().toLowerCase()))}}class DebugHandler{constructor(t,e){this.driver=t,this.adapter=e,this.debugLogA=[],this.debugLogB=[]}handleFetch(t){return __awaiter(this,void 0,void 0,(function*(){const[t,e,i]=yield Promise.all([this.driver.debugState(),this.driver.debugVersions(),this.driver.debugIdleState()]),s=`NGSW Debug Info:\n\nDriver version: 12.1.2\nDriver state: ${t.state} (${t.why})\nLatest manifest hash: ${t.latestHash||"none"}\nLast update check: ${this.since(t.lastUpdateCheck)}`,a=e.map((t=>`=== Version ${t.hash} ===\n\nClients: ${t.clients.join(", ")}`)).join("\n\n"),r=`=== Idle Task Queue ===\nLast update tick: ${this.since(i.lastTrigger)}\nLast update run: ${this.since(i.lastRun)}\nTask queue:\n${i.queue.map((t=>" * "+t)).join("\n")}\n\nDebug log:\n${this.formatDebugLog(this.debugLogB)}\n${this.formatDebugLog(this.debugLogA)}\n`;return this.adapter.newResponse(`${s}\n\n${a}\n\n${r}`,{headers:this.adapter.newHeaders({"Content-Type":"text/plain"})})}))}since(t){if(null===t)return"never";let e=this.adapter.time-t;const i=Math.floor(e/864e5);e%=864e5;const s=Math.floor(e/36e5);e%=36e5;const a=Math.floor(e/6e4);e%=6e4;const r=Math.floor(e/1e3),n=e%1e3;return(i>0?`${i}d`:"")+(s>0?`${s}h`:"")+(a>0?`${a}m`:"")+(r>0?`${r}s`:"")+(n>0?`${n}u`:"")}log(t,e=""){100===this.debugLogA.length&&(this.debugLogB=this.debugLogA,this.debugLogA=[]),"string"!=typeof t&&(t=this.errorToString(t)),this.debugLogA.push({value:t,time:this.adapter.time,context:e})}errorToString(t){return`${t.name}(${t.message}, ${t.stack})`}formatDebugLog(t){return t.map((t=>`[${this.since(t.time)}] ${t.value} ${t.context}`)).join("\n")}}class IdleScheduler{constructor(t,e,i,s){this.adapter=t,this.delay=e,this.maxDelay=i,this.debug=s,this.queue=[],this.scheduled=null,this.empty=Promise.resolve(),this.emptyResolve=null,this.lastTrigger=null,this.lastRun=null,this.oldestScheduledAt=null}trigger(){var t;return __awaiter(this,void 0,void 0,(function*(){if(this.lastTrigger=this.adapter.time,0===this.queue.length)return;null!==this.scheduled&&(this.scheduled.cancel=!0);const e={cancel:!1};this.scheduled=e;const i=this.adapter.time,s=Math.max(0,(null!==(t=this.oldestScheduledAt)&&void 0!==t?t:i)+this.maxDelay-i),a=Math.min(s,this.delay);yield this.adapter.timeout(a),e.cancel||(this.scheduled=null,yield this.execute())}))}execute(){return __awaiter(this,void 0,void 0,(function*(){for(this.lastRun=this.adapter.time;this.queue.length>0;){const t=this.queue;this.queue=[],yield t.reduce(((t,e)=>__awaiter(this,void 0,void 0,(function*(){yield t;try{yield e.run()}catch(t){this.debug.log(t,`while running idle task ${e.desc}`)}}))),Promise.resolve())}null!==this.emptyResolve&&(this.emptyResolve(),this.emptyResolve=null),this.empty=Promise.resolve(),this.oldestScheduledAt=null}))}schedule(t,e){this.queue.push({desc:t,run:e}),null===this.emptyResolve&&(this.empty=new Promise((t=>{this.emptyResolve=t}))),null===this.oldestScheduledAt&&(this.oldestScheduledAt=this.adapter.time)}get size(){return this.queue.length}get taskDescriptions(){return this.queue.map((t=>t.desc))}}function hashManifest(t){return sha1(JSON.stringify(t))}function isMsgCheckForUpdates(t){return"CHECK_FOR_UPDATES"===t.action}function isMsgActivateUpdate(t){return"ACTIVATE_UPDATE"===t.action}const s=["actions","badge","body","data","dir","icon","image","lang","renotify","requireInteraction","silent","tag","timestamp","title","vibrate"];var a=function(t){return t[t.NORMAL=0]="NORMAL",t[t.EXISTING_CLIENTS_ONLY=1]="EXISTING_CLIENTS_ONLY",t[t.SAFE_MODE=2]="SAFE_MODE",t}({});const r=self,n=new class Adapter{constructor(t,e){this.scopeUrl=t;const i=this.parseUrl(this.scopeUrl);this.origin=i.origin,this.caches=new NamedCacheStorage(e,`ngsw:${i.path}`)}newRequest(t,e){return new Request(t,e)}newResponse(t,e){return new Response(t,e)}newHeaders(t){return new Headers(t)}isClient(t){return t instanceof Client}get time(){return Date.now()}normalizeUrl(t){const e=this.parseUrl(t,this.scopeUrl);return e.origin===this.origin?e.path:t}parseUrl(t,e){const i=e?new URL(t,e):new URL(t);return{origin:i.origin,path:i.pathname,search:i.search}}timeout(t){return new Promise((e=>{setTimeout((()=>e()),t)}))}}(r.registration.scope,self.caches);new class Driver{constructor(t,e,i){this.scope=t,this.adapter=e,this.db=i,this.state=a.NORMAL,this.stateMessage="(nominal)",this.initialized=null,this.clientVersionMap=new Map,this.versions=new Map,this.latestHash=null,this.lastUpdateCheck=null,this.scheduledNavUpdateCheck=!1,this.loggedInvalidOnlyIfCachedRequest=!1,this.ngswStatePath=this.adapter.parseUrl("ngsw/state",this.scope.registration.scope).path,this.controlTable=this.db.open("control"),this.scope.addEventListener("install",(t=>{t.waitUntil(this.scope.skipWaiting())})),this.scope.addEventListener("activate",(t=>{t.waitUntil((()=>__awaiter(this,void 0,void 0,(function*(){yield this.scope.clients.claim(),this.idle.schedule("activate: cleanup-old-sw-caches",(()=>__awaiter(this,void 0,void 0,(function*(){try{yield this.cleanupOldSwCaches()}catch(t){this.debugger.log(t,"cleanupOldSwCaches @ activate: cleanup-old-sw-caches")}}))))})))()),null!==this.scope.registration.active&&this.scope.registration.active.postMessage({action:"INITIALIZE"})})),this.scope.addEventListener("fetch",(t=>this.onFetch(t))),this.scope.addEventListener("message",(t=>this.onMessage(t))),this.scope.addEventListener("push",(t=>this.onPush(t))),this.scope.addEventListener("notificationclick",(t=>this.onClick(t))),this.debugger=new DebugHandler(this,this.adapter),this.idle=new IdleScheduler(this.adapter,5e3,3e4,this.debugger)}onFetch(t){const e=t.request,i=this.scope.registration.scope,s=this.adapter.parseUrl(e.url,i);e.headers.has("ngsw-bypass")||/[?&]ngsw-bypass(?:[=&]|$)/i.test(s.search)||(s.path!==this.ngswStatePath?this.state!==a.SAFE_MODE?s.origin.startsWith("http:")&&i.startsWith("https:")?this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${e.url})`):"only-if-cached"!==e.cache||"same-origin"===e.mode?t.respondWith(this.handleFetch(t)):this.loggedInvalidOnlyIfCachedRequest||(this.loggedInvalidOnlyIfCachedRequest=!0,this.debugger.log("Ignoring invalid request: 'only-if-cached' can be set only with 'same-origin' mode",`Driver.fetch(${e.url}, cache: ${e.cache}, mode: ${e.mode})`)):t.waitUntil(this.idle.trigger()):t.respondWith(this.debugger.handleFetch(e)))}onMessage(t){if(this.state===a.SAFE_MODE)return;const e=t.data;e&&e.action&&t.waitUntil((()=>__awaiter(this,void 0,void 0,(function*(){if("INITIALIZE"===e.action)return this.ensureInitialized(t);this.adapter.isClient(t.source)&&(yield this.ensureInitialized(t),yield this.handleMessage(e,t.source))})))())}onPush(t){t.data&&t.waitUntil(this.handlePush(t.data.json()))}onClick(t){t.waitUntil(this.handleClick(t.notification,t.action))}ensureInitialized(t){return __awaiter(this,void 0,void 0,(function*(){if(null!==this.initialized)return this.initialized;try{this.initialized=this.initialize(),yield this.initialized}catch(t){throw this.state=a.SAFE_MODE,this.stateMessage=`Initialization failed due to error: ${errorToString(t)}`,t}finally{t.waitUntil(this.idle.trigger())}}))}handleMessage(t,e){return __awaiter(this,void 0,void 0,(function*(){if(isMsgCheckForUpdates(t)){const i=(()=>__awaiter(this,void 0,void 0,(function*(){yield this.checkForUpdate()})))();yield this.reportStatus(e,i,t.statusNonce)}else isMsgActivateUpdate(t)&&(yield this.reportStatus(e,this.updateClient(e),t.statusNonce))}))}handlePush(t){return __awaiter(this,void 0,void 0,(function*(){if(yield this.broadcast({type:"PUSH",data:t}),!t.notification||!t.notification.title)return;const e=t.notification;let i={};s.filter((t=>e.hasOwnProperty(t))).forEach((t=>i[t]=e[t])),yield this.scope.registration.showNotification(e.title,i)}))}handleClick(t,e){var i,a;return __awaiter(this,void 0,void 0,(function*(){t.close();const r={};s.filter((e=>e in t)).forEach((e=>r[e]=t[e]));const n=""===e||void 0===e?"default":e,o=null===(i=null==t?void 0:t.data)||void 0===i?void 0:i.onActionClick[n],h=new URL(null!==(a=null==o?void 0:o.url)&&void 0!==a?a:"",this.scope.registration.scope).href;switch(null==o?void 0:o.operation){case"openWindow":yield this.scope.clients.openWindow(h);break;case"focusLastFocusedOrOpen":{let t=yield this.getLastFocusedMatchingClient(this.scope);t?yield null==t?void 0:t.focus():yield this.scope.clients.openWindow(h);break}case"navigateLastFocusedOrOpen":{let t=yield this.getLastFocusedMatchingClient(this.scope);t?(t=yield t.navigate(h),yield null==t?void 0:t.focus()):yield this.scope.clients.openWindow(h);break}}yield this.broadcast({type:"NOTIFICATION_CLICK",data:{action:e,notification:r}})}))}getLastFocusedMatchingClient(t){return __awaiter(this,void 0,void 0,(function*(){return(yield t.clients.matchAll({type:"window"}))[0]}))}reportStatus(t,e,i){return __awaiter(this,void 0,void 0,(function*(){const s={type:"STATUS",nonce:i,status:!0};try{yield e,t.postMessage(s)}catch(e){t.postMessage(Object.assign(Object.assign({},s),{status:!1,error:e.toString()}))}}))}updateClient(t){return __awaiter(this,void 0,void 0,(function*(){const e=this.clientVersionMap.get(t.id);if(e===this.latestHash)return;let i;if(void 0!==e){const t=this.versions.get(e);i=this.mergeHashWithAppData(t.manifest,e)}this.clientVersionMap.set(t.id,this.latestHash),yield this.sync();const s=this.versions.get(this.latestHash),a={type:"UPDATE_ACTIVATED",previous:i,current:this.mergeHashWithAppData(s.manifest,this.latestHash)};t.postMessage(a)}))}handleFetch(t){return __awaiter(this,void 0,void 0,(function*(){try{yield this.ensureInitialized(t)}catch(e){return this.safeFetch(t.request)}"navigate"!==t.request.mode||this.scheduledNavUpdateCheck||(this.scheduledNavUpdateCheck=!0,this.idle.schedule("check-updates-on-navigation",(()=>__awaiter(this,void 0,void 0,(function*(){this.scheduledNavUpdateCheck=!1,yield this.checkForUpdate()})))));const e=yield this.assignVersion(t);let i=null;try{if(null!==e)try{i=yield e.handleFetch(t.request,t)}catch(i){if(i.isUnrecoverableState&&(yield this.notifyClientsAboutUnrecoverableState(e,i.message)),i.isCritical)return yield this.versionFailed(e,i),this.safeFetch(t.request);throw i}return null===i?this.safeFetch(t.request):i}finally{t.waitUntil(this.idle.trigger())}}))}initialize(){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.controlTable;let e,i,s;try{if([e,i,s]=yield Promise.all([t.read("manifests"),t.read("assignments"),t.read("latest")]),!this.versions.has(s.latest)&&!e.hasOwnProperty(s.latest))throw this.debugger.log(`Missing manifest for latest version hash ${s.latest}`,"initialize: read from DB"),new Error(`Missing manifest for latest hash ${s.latest}`);this.idle.schedule("init post-load (update)",(()=>__awaiter(this,void 0,void 0,(function*(){yield this.checkForUpdate()}))))}catch(a){const r=yield this.fetchLatestManifest(),n=hashManifest(r);e={[n]:r},i={},s={latest:n},yield Promise.all([t.write("manifests",e),t.write("assignments",i),t.write("latest",s)])}if(this.idle.schedule("init post-load (cleanup)",(()=>__awaiter(this,void 0,void 0,(function*(){yield this.cleanupCaches()})))),Object.keys(e).forEach((t=>{const i=e[t];this.versions.has(t)||this.versions.set(t,new AppVersion(this.scope,this.adapter,this.db,this.idle,this.debugger,i,t))})),Object.keys(i).forEach((t=>{const e=i[t];this.versions.has(e)?this.clientVersionMap.set(t,e):(this.clientVersionMap.set(t,s.latest),this.debugger.log(`Unknown version ${e} mapped for client ${t}, using latest instead`,"initialize: map assignments"))})),this.latestHash=s.latest,!this.versions.has(s.latest))throw new Error(`Invariant violated (initialize): latest hash ${s.latest} has no known manifest`);yield Promise.all(Object.keys(e).map((t=>__awaiter(this,void 0,void 0,(function*(){try{yield this.scheduleInitialization(this.versions.get(t))}catch(e){return this.debugger.log(e,`initialize: schedule init of ${t}`),!1}})))))}))}lookupVersionByHash(t,e="lookupVersionByHash"){if(!this.versions.has(t))throw new Error(`Invariant violated (${e}): want AppVersion for ${t} but not loaded`);return this.versions.get(t)}assignVersion(t){return __awaiter(this,void 0,void 0,(function*(){const e=t.resultingClientId||t.clientId;if(e){if(this.clientVersionMap.has(e)){const i=this.clientVersionMap.get(e);let s=this.lookupVersionByHash(i,"assignVersion");if(this.state===a.NORMAL&&i!==this.latestHash&&s.isNavigationRequest(t.request)){if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");const t=yield this.scope.clients.get(e);t&&(yield this.updateClient(t)),s=this.lookupVersionByHash(this.latestHash,"assignVersion")}return s}if(this.state!==a.NORMAL)return null;if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");return this.clientVersionMap.set(e,this.latestHash),yield this.sync(),this.lookupVersionByHash(this.latestHash,"assignVersion")}if(this.state!==a.NORMAL)return null;if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");return this.lookupVersionByHash(this.latestHash,"assignVersion")}))}fetchLatestManifest(t=!1){return __awaiter(this,void 0,void 0,(function*(){const e=yield this.safeFetch(this.adapter.newRequest("ngsw.json?ngsw-cache-bust="+Math.random()));if(!e.ok){if(404===e.status)yield this.deleteAllCaches(),yield this.scope.registration.unregister();else if((503===e.status||504===e.status)&&t)return null;throw new Error(`Manifest fetch failed! (status: ${e.status})`)}return this.lastUpdateCheck=this.adapter.time,e.json()}))}deleteAllCaches(){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.adapter.caches.keys();yield Promise.all(t.map((t=>this.adapter.caches.delete(t))))}))}scheduleInitialization(t){return __awaiter(this,void 0,void 0,(function*(){const initialize=()=>__awaiter(this,void 0,void 0,(function*(){try{yield t.initializeFully()}catch(e){this.debugger.log(e,`initializeFully for ${t.manifestHash}`),yield this.versionFailed(t,e)}}));if(this.scope.registration.scope.indexOf("://localhost")>-1)return initialize();this.idle.schedule(`initialization(${t.manifestHash})`,initialize)}))}versionFailed(t,e){return __awaiter(this,void 0,void 0,(function*(){const i=Array.from(this.versions.entries()).find((([e,i])=>i===t));if(void 0===i)return;const s=i[0],r=Array.from(this.clientVersionMap.entries()).filter((([t,e])=>e===s)).map((([t])=>t));this.latestHash===s?(this.state=a.EXISTING_CLIENTS_ONLY,this.stateMessage=`Degraded due to: ${errorToString(e)}`,r.forEach((t=>this.clientVersionMap.delete(t)))):r.forEach((t=>this.clientVersionMap.set(t,this.latestHash)));try{yield this.sync()}catch(t){this.debugger.log(t,`Driver.versionFailed(${e.message||e})`)}}))}setupUpdate(t,e){return __awaiter(this,void 0,void 0,(function*(){const i=new AppVersion(this.scope,this.adapter,this.db,this.idle,this.debugger,t,e);if(1!==t.configVersion)throw yield this.deleteAllCaches(),yield this.scope.registration.unregister(),new Error(`Invalid config version: expected 1, got ${t.configVersion}.`);yield i.initializeFully(this),this.versions.set(e,i),this.latestHash=e,this.state===a.EXISTING_CLIENTS_ONLY&&(this.state=a.NORMAL,this.stateMessage="(nominal)"),yield this.sync(),yield this.notifyClientsAboutUpdate(i)}))}checkForUpdate(){return __awaiter(this,void 0,void 0,(function*(){let t="(unknown)";try{const e=yield this.fetchLatestManifest(!0);return null===e?(this.debugger.log("Check for update aborted. (Client or server offline.)"),!1):(t=hashManifest(e),!this.versions.has(t)&&(yield this.setupUpdate(e,t),!0))}catch(e){return this.debugger.log(e,`Error occurred while updating to manifest ${t}`),this.state=a.EXISTING_CLIENTS_ONLY,this.stateMessage=`Degraded due to failed initialization: ${errorToString(e)}`,!1}}))}sync(){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.controlTable,e={};this.versions.forEach(((t,i)=>{e[i]=t.manifest}));const i={};this.clientVersionMap.forEach(((t,e)=>{i[e]=t}));const s={latest:this.latestHash};yield Promise.all([t.write("manifests",e),t.write("assignments",i),t.write("latest",s)])}))}cleanupCaches(){return __awaiter(this,void 0,void 0,(function*(){try{const t=new Set((yield this.scope.clients.matchAll()).map((t=>t.id))),e=Array.from(this.clientVersionMap.keys());e.filter((e=>!t.has(e))).forEach((t=>this.clientVersionMap.delete(t)));const i=new Set(this.clientVersionMap.values());Array.from(this.versions.keys()).filter((t=>!i.has(t)&&t!==this.latestHash)).forEach((t=>this.versions.delete(t))),yield this.sync();const s=yield this.adapter.caches.keys(),a=new Set(yield this.getCacheNames()),r=s.filter((t=>!a.has(t)));yield Promise.all(r.map((t=>this.adapter.caches.delete(t))))}catch(t){this.debugger.log(t,"cleanupCaches")}}))}cleanupOldSwCaches(){return __awaiter(this,void 0,void 0,(function*(){const t=this.adapter.caches.original,e=(yield t.keys()).filter((t=>/^ngsw:(?!\/)/.test(t)));yield Promise.all(e.map((e=>t.delete(e))))}))}lookupResourceWithHash(t,e){return Array.from(this.versions.values()).reduce(((i,s)=>__awaiter(this,void 0,void 0,(function*(){return null!==(yield i)?i:s.lookupResourceWithHash(t,e)}))),Promise.resolve(null))}lookupResourceWithoutHash(t){return __awaiter(this,void 0,void 0,(function*(){yield this.initialized;const e=this.versions.get(this.latestHash);return e?e.lookupResourceWithoutHash(t):null}))}previouslyCachedResources(){return __awaiter(this,void 0,void 0,(function*(){yield this.initialized;const t=this.versions.get(this.latestHash);return t?t.previouslyCachedResources():[]}))}recentCacheStatus(e){return __awaiter(this,void 0,void 0,(function*(){const i=this.versions.get(this.latestHash);return i?i.recentCacheStatus(e):t.NOT_CACHED}))}mergeHashWithAppData(t,e){return{hash:e,appData:t.appData}}notifyClientsAboutUnrecoverableState(t,e){return __awaiter(this,void 0,void 0,(function*(){const i=Array.from(this.versions.entries()).find((([e,i])=>i===t));if(void 0===i)return;const s=i[0],a=Array.from(this.clientVersionMap.entries()).filter((([t,e])=>e===s)).map((([t])=>t));yield Promise.all(a.map((t=>__awaiter(this,void 0,void 0,(function*(){const i=yield this.scope.clients.get(t);i&&i.postMessage({type:"UNRECOVERABLE_STATE",reason:e})})))))}))}notifyClientsAboutUpdate(t){return __awaiter(this,void 0,void 0,(function*(){yield this.initialized;const e=yield this.scope.clients.matchAll();yield Promise.all(e.map((e=>__awaiter(this,void 0,void 0,(function*(){const i=this.clientVersionMap.get(e.id);if(void 0===i)return;if(i===this.latestHash)return;const s=this.versions.get(i),a={type:"UPDATE_AVAILABLE",current:this.mergeHashWithAppData(s.manifest,i),available:this.mergeHashWithAppData(t.manifest,this.latestHash)};e.postMessage(a)})))))}))}broadcast(t){return __awaiter(this,void 0,void 0,(function*(){(yield this.scope.clients.matchAll()).forEach((e=>{e.postMessage(t)}))}))}debugState(){return __awaiter(this,void 0,void 0,(function*(){return{state:a[this.state],why:this.stateMessage,latestHash:this.latestHash,lastUpdateCheck:this.lastUpdateCheck}}))}debugVersions(){return __awaiter(this,void 0,void 0,(function*(){return Array.from(this.versions.keys()).map((t=>{const e=this.versions.get(t),i=Array.from(this.clientVersionMap.entries()).filter((([e,i])=>i===t)).map((([t,e])=>t));return{hash:t,manifest:e.manifest,clients:i,status:""}}))}))}debugIdleState(){return __awaiter(this,void 0,void 0,(function*(){return{queue:this.idle.taskDescriptions,lastTrigger:this.idle.lastTrigger,lastRun:this.idle.lastRun}}))}safeFetch(t){return __awaiter(this,void 0,void 0,(function*(){try{return yield this.scope.fetch(t)}catch(e){return this.debugger.log(e,`Driver.fetch(${t.url})`),this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}}))}getCacheNames(){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.controlTable,e=Array.from(this.versions.values()),i=yield Promise.all(e.map((t=>t.getCacheNames())));return[t.cacheName].concat(...i)}))}}(r,n,new class CacheDatabase{constructor(t){this.adapter=t,this.cacheNamePrefix="db",this.tables=new Map}delete(t){return this.tables.has(t)&&this.tables.delete(t),this.adapter.caches.delete(`${this.cacheNamePrefix}:${t}`)}list(){return __awaiter(this,void 0,void 0,(function*(){const t=`${this.cacheNamePrefix}:`;return(yield this.adapter.caches.keys()).filter((e=>e.startsWith(t))).map((e=>e.slice(t.length)))}))}open(t,e){return __awaiter(this,void 0,void 0,(function*(){if(!this.tables.has(t)){const i=yield this.adapter.caches.open(`${this.cacheNamePrefix}:${t}`),s=new CacheTable(t,i,this.adapter,e);this.tables.set(t,s)}return this.tables.get(t)}))}}(n))}();