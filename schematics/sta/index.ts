import { colors } from '@angular/cli/utilities/color';

import { normalize } from '@angular-devkit/core';
import { ProjectDefinition } from '@angular-devkit/core/src/workspace';
import { Rule, SchematicsException, Tree, chain, SchematicContext } from '@angular-devkit/schematics';
import { rmdirSync, mkdirSync, existsSync } from 'fs';
import { resolve, join } from 'path';
import { generateApi, GenerateApiOutput } from 'swagger-typescript-api';

import { readJSON, writeJSON } from '../utils/json';
import { getProject } from '../utils/workspace';
import { Schema } from './schema';

let project: ProjectDefinition;

export interface STAConfig {
  name?: string;

  url?: string;

  filePath?: string;

  output?: string;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generateApiParams?: any;
}

const filePrefix = `/* eslint-disable */
/*
 * Automatically generated by 'ng g ng-alain:sta'
 * @see https://ng-alain.com/cli/sta
 *
 * Inspired by: https://github.com/acacode/swagger-typescript-api
 */

`;

function addPathInTsConfig(name: string): Rule {
  return (tree: Tree) => {
    const json = readJSON(tree, 'tsconfig.json', 'compilerOptions');
    if (json == null) return tree;
    if (!json.compilerOptions) json.compilerOptions = {};
    if (!json.compilerOptions.paths) json.compilerOptions.paths = {};
    const paths = json.compilerOptions.paths;
    paths[`@${name}`] = [`src/app/${name}/index`];
    paths[`@${name}/*`] = [`src/app/${name}/*`];
    writeJSON(tree, 'tsconfig.json', json);
    return tree;
  };
}

function cleanOutput(p: string) {
  try {
    rmdirSync(p, { recursive: true });
    mkdirSync(p);
  } catch (e) {}
}

function fix(output: string, res: GenerateApiOutput, tree: Tree, context: SchematicContext) {
  const indexList = [`models`, `_base.service`];
  const basePath = normalize(join(project.root, output.replace(process.cwd(), '')));
  try {
    // definitions
    const dataTpl = res.getTemplate({ name: 'dataContracts', fileName: 'data-contracts.eta' });
    const dataContent = res.renderTemplate(dataTpl, { ...res.configuration });
    tree.create(`${basePath}/models.ts`, filePrefix + res.formatTSContent(dataContent));

    // Base Service
    const baseServiceTpl = res.getTemplate({ name: 'baseService', fileName: 'base.service.eta' });
    const baseServiceContent = res.renderTemplate(baseServiceTpl, { ...res.configuration });
    tree.create(`${basePath}/_base.service.ts`, filePrefix + res.formatTSContent(baseServiceContent));

    // Tag Service
    const dtoTypeTpl = res.getTemplate({ name: 'dto-type', fileName: 'dto-type.eta' });
    const serviceTpl = res.getTemplate({ name: 'service', fileName: 'service.eta' });
    res.configuration.routes.combined.forEach(route => {
      // dto
      const dtoContent = res.formatTSContent(
        res.renderTemplate(dtoTypeTpl, {
          ...res.configuration,
          route
        })
      );
      if (dtoContent.trim().length > 10) {
        tree.create(`${basePath}/${route.moduleName}.dtos.ts`, filePrefix + dtoContent);
        indexList.push(`${route.moduleName}.dtos`);
      }

      // service
      const serviceContent = res.renderTemplate(serviceTpl, {
        ...res.configuration,
        route
      });
      tree.create(`${basePath}/${route.moduleName}.service.ts`, filePrefix + res.formatTSContent(serviceContent));
      indexList.push(`${route.moduleName}.service`);
    });
    // Index
    tree.create(`${basePath}/index.ts`, filePrefix + indexList.map(name => `export * from './${name}';`).join('\n'));
  } catch (ex) {
    throw new SchematicsException(`Parse error: ${ex}`);
  }
}

function genProxy(config: STAConfig): Rule {
  return (tree: Tree, context: SchematicContext) => {
    context.logger.info(colors.blue(`- Name: ${config.name}`));
    const output = (config.output = resolve(process.cwd(), config.output ?? `./src/app/${config.name}`));
    const templates = resolve(__dirname, './templates');
    if (config.url) {
      context.logger.info(colors.blue(`- Using url data: ${config.url}`));
    } else if (config.filePath) {
      context.logger.info(colors.blue(`- Using file data: ${config.filePath}`));
    }
    context.logger.info(colors.blue(`- Output: ${output}`));

    return new Promise<void>(resolve => {
      context.logger.info(colors.blue(`Start generating...`));
      generateApi({
        name: `${config.name}.ts`,
        url: config.url,
        input: config.filePath,
        output,
        templates,
        toJS: false,
        modular: true,
        cleanOutput: true,
        generateUnionEnums: true,
        generateClient: true,
        extractRequestParams: false,
        generateResponses: false,
        generateRouteTypes: true,
        generateApi: true,
        silent: true,
        disableStrictSSL: true,
        moduleNameFirstTag: true,
        ...config.generateApiParams
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any)
        .then((res: GenerateApiOutput) => {
          cleanOutput(output);
          fix(output, res, tree, context);
          resolve();
        })
        .catch(ex => {
          throw new SchematicsException(`Generate error: ${ex}`);
        });
    });
  };
}

function finished(): Rule {
  return (_: Tree, context: SchematicContext) => {
    context.logger.info(colors.green(`âœ“  Finished, refer to: https://ng-alain.com/cli/sta`));
  };
}

function tryLoadConfig(configPath?: string): STAConfig | null {
  if (!configPath || configPath.length <= 0) return null;

  try {
    const configFile = resolve(process.cwd(), configPath);
    if (existsSync(configFile)) {
      return require(configFile);
    }
  } catch (err) {
    console.error('Invalid config file', err);
  }
}

export default function (options: Schema): Rule {
  return async (tree: Tree) => {
    project = (await getProject(tree, options.project)).project;
    const config: STAConfig = {
      name: 'proxy',
      ...tryLoadConfig(options.config),
      ...options
    };

    return chain([addPathInTsConfig(config.name), genProxy(config), finished()]);
  };
}
