import { colors } from '@angular/cli/utilities/color';

import { normalize } from '@angular-devkit/core';
import { ProjectDefinition } from '@angular-devkit/core/src/workspace';
import { Rule, SchematicsException, Tree, chain, SchematicContext } from '@angular-devkit/schematics';
import { rmdirSync, mkdirSync } from 'fs';
import { resolve, join } from 'path';
import { generateApi, GenerateApiOutput } from 'swagger-typescript-api';

import { readJSON, writeJSON } from '../utils/json';
import { getProject } from '../utils/workspace';
import { Schema } from './schema';

let project: ProjectDefinition;

export interface STAConfig {
  name?: string;

  url?: string;

  filePath?: string;

  output?: string;

  templates?: string;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  spec?: any;
}

const filePrefix = `/* eslint-disable */
/*
 * Automatically generated by 'ng g ng-alain:sta'
 * @see https://ng-alain.com/cli/sta
 *
 * Inspired by: https://github.com/acacode/swagger-typescript-api
 */

`;

export const DEFAULT_SPEC = {
  openapi: '3.0.1',
  info: {
    title: 'Title',
    version: '1.0.0'
  },
  tags: [
    {
      name: 'user'
    }
  ],
  paths: {
    '/user': {
      get: {
        summary: 'Info',
        tags: ['user'],
        responses: {
          '200': {
            description: 'Success',
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  properties: {}
                }
              }
            }
          }
        }
      }
    }
  }
};

function addPathInTsConfig(name: string): Rule {
  return (tree: Tree) => {
    const json = readJSON(tree, 'tsconfig.json', 'compilerOptions');
    if (json == null) return tree;
    if (!json.compilerOptions) json.compilerOptions = {};
    if (!json.compilerOptions.paths) json.compilerOptions.paths = {};
    const paths = json.compilerOptions.paths;
    paths[`@${name}`] = [`src/app/${name}/index`];
    paths[`@${name}/*`] = [`src/app/${name}/*`];
    writeJSON(tree, 'tsconfig.json', json);
    return tree;
  };
}

function cleanOutput(p: string) {
  try {
    rmdirSync(p, { recursive: true });
    mkdirSync(p);
  } catch (e) {}
}

function fix(output: string, res: GenerateApiOutput, tree: Tree, context: SchematicContext) {
  const indexList = [`models`, `base.service`];
  const basePath = normalize(join(project.root, output.replace(process.cwd(), '')));
  try {
    // definitions
    const dataTpl = res.getTemplate({ name: 'dataContracts', fileName: 'data-contracts.eta' });
    const dataContent = res.renderTemplate(dataTpl, { ...res.configuration });
    tree.create(`${basePath}/models.ts`, filePrefix + res.formatTSContent(dataContent));

    // Base Service
    const baseServiceTpl = res.getTemplate({ name: 'baseService', fileName: 'base.service.eta' });
    const baseServiceContent = res.renderTemplate(baseServiceTpl, { ...res.configuration });
    tree.create(`${basePath}/base.service.ts`, filePrefix + res.formatTSContent(baseServiceContent));

    // Tag Service
    const serviceTpl = res.getTemplate({ name: 'service', fileName: 'service.eta' });
    res.configuration.routes.combined.forEach(route => {
      const moduleContent = res.renderTemplate(serviceTpl, {
        ...res.configuration,
        route
      });
      tree.create(`${basePath}/${route.moduleName}.service.ts`, filePrefix + res.formatTSContent(moduleContent));
      indexList.push(`${route.moduleName}.service`);
    });
    // Index
    tree.create(`${basePath}/index.ts`, filePrefix + indexList.map(name => `export * from './${name}';`).join('\n'));
  } catch (ex) {
    throw new SchematicsException(`Parse error: ${ex}`);
  }
}

function genProxy(config: STAConfig): Rule {
  return (tree: Tree, context: SchematicContext) => {
    context.logger.info(colors.blue(`- Name: ${config.name}`));
    const output = (config.output = resolve(process.cwd(), config.output ?? `./src/app/${config.name}`));
    const templates = config.templates ?? resolve(__dirname, './templates');
    let dataType: 'url' | 'filePath' | 'spec' = 'spec';
    if (config.url) {
      dataType = 'url';
      context.logger.info(colors.blue(`- Using url data: ${config.url}`));
    } else if (config.filePath) {
      dataType = 'filePath';
      context.logger.info(colors.blue(`- Using file data: ${config.filePath}`));
    } else {
      context.logger.info(colors.blue(`- Using spec data`));
    }
    context.logger.info(colors.blue(`- Output: ${output}`));

    return new Promise<void>(resolve => {
      context.logger.info(colors.blue(`Start generating...`));
      generateApi({
        name: `${config.name}.ts`,
        spec: dataType !== 'spec' ? null : DEFAULT_SPEC,
        url: config.url,
        input: config.filePath,
        output,
        templates,
        toJS: false,
        modular: true,
        cleanOutput: true,
        generateUnionEnums: true,
        generateClient: true,
        extractRequestParams: false,
        generateResponses: true,
        generateRouteTypes: true,
        generateApi: true,
        silent: true
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any)
        .then((res: GenerateApiOutput) => {
          cleanOutput(output);
          fix(output, res, tree, context);
          resolve();
        })
        .catch(ex => {
          throw new SchematicsException(`Generate error: ${ex}`);
        });
    });
  };
}

function finished(): Rule {
  return (_: Tree, context: SchematicContext) => {
    context.logger.info(colors.green(`âœ“  Finished, refer to: https://ng-alain.com/cli/sta`));
  };
}

export default function (options: Schema): Rule {
  return async (tree: Tree, context: SchematicContext) => {
    project = (await getProject(tree, options.project)).project;
    const config = {
      name: 'proxy',
      ...options
    };

    return chain([addPathInTsConfig(config.name), genProxy(config), finished()]);
  };
}
